/* automatically generated by rust-bindgen 0.59.2 */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals, unused)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const CPU_FEATURES_COMPILED_X86_AES: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_F16C: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_BMI: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_BMI2: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_SSE: u32 = 1;
pub const CPU_FEATURES_COMPILED_X86_SSE2: u32 = 1;
pub const CPU_FEATURES_COMPILED_X86_SSE3: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_SSSE3: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_SSE4_1: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_SSE4_2: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_AVX: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_AVX2: u32 = 0;
pub const CPU_FEATURES_MAX_CACHE_LEVEL: u32 = 10;
pub const CacheType_CPU_FEATURE_CACHE_NULL: CacheType = 0;
pub const CacheType_CPU_FEATURE_CACHE_DATA: CacheType = 1;
pub const CacheType_CPU_FEATURE_CACHE_INSTRUCTION: CacheType = 2;
pub const CacheType_CPU_FEATURE_CACHE_UNIFIED: CacheType = 3;
pub const CacheType_CPU_FEATURE_CACHE_TLB: CacheType = 4;
pub const CacheType_CPU_FEATURE_CACHE_DTLB: CacheType = 5;
pub const CacheType_CPU_FEATURE_CACHE_STLB: CacheType = 6;
pub const CacheType_CPU_FEATURE_CACHE_PREFETCH: CacheType = 7;
pub type CacheType = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CacheLevelInfo {
    pub level: cty::c_int,
    pub cache_type: CacheType,
    pub cache_size: cty::c_int,
    pub ways: cty::c_int,
    pub line_size: cty::c_int,
    pub tlb_entries: cty::c_int,
    pub partitioning: cty::c_int,
}
#[test]
fn bindgen_test_layout_CacheLevelInfo() {
    assert_eq!(
        ::core::mem::size_of::<CacheLevelInfo>(),
        28usize,
        concat!("Size of: ", stringify!(CacheLevelInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<CacheLevelInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(CacheLevelInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).cache_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(cache_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).cache_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).ways as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(ways)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).line_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(line_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).tlb_entries as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(tlb_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).partitioning as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(partitioning)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CacheInfo {
    pub size: cty::c_int,
    pub levels: [CacheLevelInfo; 10usize],
}
#[test]
fn bindgen_test_layout_CacheInfo() {
    assert_eq!(
        ::core::mem::size_of::<CacheInfo>(),
        284usize,
        concat!("Size of: ", stringify!(CacheInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<CacheInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(CacheInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheInfo>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheInfo>())).levels as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheInfo),
            "::",
            stringify!(levels)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct Aarch64Features {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_Aarch64Features() {
    assert_eq!(
        ::core::mem::size_of::<Aarch64Features>(),
        8usize,
        concat!("Size of: ", stringify!(Aarch64Features))
    );
    assert_eq!(
        ::core::mem::align_of::<Aarch64Features>(),
        4usize,
        concat!("Alignment of ", stringify!(Aarch64Features))
    );
}
impl Aarch64Features {
    #[inline]
    pub fn fp(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fp(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn asimd(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_asimd(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn evtstrm(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_evtstrm(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aes(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aes(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pmull(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pmull(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sha1(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sha1(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sha2(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sha2(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn crc32(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crc32(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn atomics(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_atomics(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fphp(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fphp(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn asimdhp(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_asimdhp(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpuid(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpuid(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn asimdrdm(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_asimdrdm(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn jscvt(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_jscvt(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fcma(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fcma(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lrcpc(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lrcpc(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dcpop(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dcpop(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sha3(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sha3(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sm3(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sm3(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sm4(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sm4(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn asimddp(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_asimddp(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sha512(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sha512(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sve(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sve(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn asimdfhm(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_asimdfhm(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dit(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dit(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uscat(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uscat(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ilrcpc(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ilrcpc(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flagm(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flagm(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssbs(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssbs(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sb(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sb(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn paca(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_paca(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pacg(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pacg(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dcpodp(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dcpodp(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sve2(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sve2(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sveaes(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sveaes(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn svepmull(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_svepmull(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn svebitperm(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_svebitperm(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn svesha3(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_svesha3(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn svesm4(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_svesm4(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flagm2(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flagm2(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frint(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frint(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn svei8mm(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_svei8mm(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn svef32mm(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_svef32mm(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn svef64mm(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_svef64mm(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn svebf16(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_svebf16(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn i8mm(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_i8mm(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bf16(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bf16(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dgh(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dgh(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rng(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rng(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bti(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bti(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mte(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mte(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ecv(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ecv(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn afp(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_afp(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rpres(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rpres(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fp: cty::c_int,
        asimd: cty::c_int,
        evtstrm: cty::c_int,
        aes: cty::c_int,
        pmull: cty::c_int,
        sha1: cty::c_int,
        sha2: cty::c_int,
        crc32: cty::c_int,
        atomics: cty::c_int,
        fphp: cty::c_int,
        asimdhp: cty::c_int,
        cpuid: cty::c_int,
        asimdrdm: cty::c_int,
        jscvt: cty::c_int,
        fcma: cty::c_int,
        lrcpc: cty::c_int,
        dcpop: cty::c_int,
        sha3: cty::c_int,
        sm3: cty::c_int,
        sm4: cty::c_int,
        asimddp: cty::c_int,
        sha512: cty::c_int,
        sve: cty::c_int,
        asimdfhm: cty::c_int,
        dit: cty::c_int,
        uscat: cty::c_int,
        ilrcpc: cty::c_int,
        flagm: cty::c_int,
        ssbs: cty::c_int,
        sb: cty::c_int,
        paca: cty::c_int,
        pacg: cty::c_int,
        dcpodp: cty::c_int,
        sve2: cty::c_int,
        sveaes: cty::c_int,
        svepmull: cty::c_int,
        svebitperm: cty::c_int,
        svesha3: cty::c_int,
        svesm4: cty::c_int,
        flagm2: cty::c_int,
        frint: cty::c_int,
        svei8mm: cty::c_int,
        svef32mm: cty::c_int,
        svef64mm: cty::c_int,
        svebf16: cty::c_int,
        i8mm: cty::c_int,
        bf16: cty::c_int,
        dgh: cty::c_int,
        rng: cty::c_int,
        bti: cty::c_int,
        mte: cty::c_int,
        ecv: cty::c_int,
        afp: cty::c_int,
        rpres: cty::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fp: u32 = unsafe { ::core::mem::transmute(fp) };
            fp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let asimd: u32 = unsafe { ::core::mem::transmute(asimd) };
            asimd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let evtstrm: u32 = unsafe { ::core::mem::transmute(evtstrm) };
            evtstrm as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let aes: u32 = unsafe { ::core::mem::transmute(aes) };
            aes as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let pmull: u32 = unsafe { ::core::mem::transmute(pmull) };
            pmull as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sha1: u32 = unsafe { ::core::mem::transmute(sha1) };
            sha1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sha2: u32 = unsafe { ::core::mem::transmute(sha2) };
            sha2 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let crc32: u32 = unsafe { ::core::mem::transmute(crc32) };
            crc32 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let atomics: u32 = unsafe { ::core::mem::transmute(atomics) };
            atomics as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let fphp: u32 = unsafe { ::core::mem::transmute(fphp) };
            fphp as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let asimdhp: u32 = unsafe { ::core::mem::transmute(asimdhp) };
            asimdhp as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let cpuid: u32 = unsafe { ::core::mem::transmute(cpuid) };
            cpuid as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let asimdrdm: u32 = unsafe { ::core::mem::transmute(asimdrdm) };
            asimdrdm as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let jscvt: u32 = unsafe { ::core::mem::transmute(jscvt) };
            jscvt as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fcma: u32 = unsafe { ::core::mem::transmute(fcma) };
            fcma as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let lrcpc: u32 = unsafe { ::core::mem::transmute(lrcpc) };
            lrcpc as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let dcpop: u32 = unsafe { ::core::mem::transmute(dcpop) };
            dcpop as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let sha3: u32 = unsafe { ::core::mem::transmute(sha3) };
            sha3 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sm3: u32 = unsafe { ::core::mem::transmute(sm3) };
            sm3 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let sm4: u32 = unsafe { ::core::mem::transmute(sm4) };
            sm4 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let asimddp: u32 = unsafe { ::core::mem::transmute(asimddp) };
            asimddp as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let sha512: u32 = unsafe { ::core::mem::transmute(sha512) };
            sha512 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let sve: u32 = unsafe { ::core::mem::transmute(sve) };
            sve as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let asimdfhm: u32 = unsafe { ::core::mem::transmute(asimdfhm) };
            asimdfhm as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let dit: u32 = unsafe { ::core::mem::transmute(dit) };
            dit as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let uscat: u32 = unsafe { ::core::mem::transmute(uscat) };
            uscat as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ilrcpc: u32 = unsafe { ::core::mem::transmute(ilrcpc) };
            ilrcpc as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let flagm: u32 = unsafe { ::core::mem::transmute(flagm) };
            flagm as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ssbs: u32 = unsafe { ::core::mem::transmute(ssbs) };
            ssbs as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let sb: u32 = unsafe { ::core::mem::transmute(sb) };
            sb as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let paca: u32 = unsafe { ::core::mem::transmute(paca) };
            paca as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let pacg: u32 = unsafe { ::core::mem::transmute(pacg) };
            pacg as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let dcpodp: u32 = unsafe { ::core::mem::transmute(dcpodp) };
            dcpodp as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let sve2: u32 = unsafe { ::core::mem::transmute(sve2) };
            sve2 as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let sveaes: u32 = unsafe { ::core::mem::transmute(sveaes) };
            sveaes as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let svepmull: u32 = unsafe { ::core::mem::transmute(svepmull) };
            svepmull as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let svebitperm: u32 = unsafe { ::core::mem::transmute(svebitperm) };
            svebitperm as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let svesha3: u32 = unsafe { ::core::mem::transmute(svesha3) };
            svesha3 as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let svesm4: u32 = unsafe { ::core::mem::transmute(svesm4) };
            svesm4 as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let flagm2: u32 = unsafe { ::core::mem::transmute(flagm2) };
            flagm2 as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let frint: u32 = unsafe { ::core::mem::transmute(frint) };
            frint as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let svei8mm: u32 = unsafe { ::core::mem::transmute(svei8mm) };
            svei8mm as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let svef32mm: u32 = unsafe { ::core::mem::transmute(svef32mm) };
            svef32mm as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let svef64mm: u32 = unsafe { ::core::mem::transmute(svef64mm) };
            svef64mm as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let svebf16: u32 = unsafe { ::core::mem::transmute(svebf16) };
            svebf16 as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let i8mm: u32 = unsafe { ::core::mem::transmute(i8mm) };
            i8mm as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let bf16: u32 = unsafe { ::core::mem::transmute(bf16) };
            bf16 as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let dgh: u32 = unsafe { ::core::mem::transmute(dgh) };
            dgh as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let rng: u32 = unsafe { ::core::mem::transmute(rng) };
            rng as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let bti: u32 = unsafe { ::core::mem::transmute(bti) };
            bti as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let mte: u32 = unsafe { ::core::mem::transmute(mte) };
            mte as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let ecv: u32 = unsafe { ::core::mem::transmute(ecv) };
            ecv as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let afp: u32 = unsafe { ::core::mem::transmute(afp) };
            afp as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let rpres: u32 = unsafe { ::core::mem::transmute(rpres) };
            rpres as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Aarch64Info {
    pub features: Aarch64Features,
    pub implementer: cty::c_int,
    pub variant: cty::c_int,
    pub part: cty::c_int,
    pub revision: cty::c_int,
}
#[test]
fn bindgen_test_layout_Aarch64Info() {
    assert_eq!(
        ::core::mem::size_of::<Aarch64Info>(),
        24usize,
        concat!("Size of: ", stringify!(Aarch64Info))
    );
    assert_eq!(
        ::core::mem::align_of::<Aarch64Info>(),
        4usize,
        concat!("Alignment of ", stringify!(Aarch64Info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aarch64Info>())).features as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aarch64Info),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aarch64Info>())).implementer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Aarch64Info),
            "::",
            stringify!(implementer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aarch64Info>())).variant as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Aarch64Info),
            "::",
            stringify!(variant)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aarch64Info>())).part as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Aarch64Info),
            "::",
            stringify!(part)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Aarch64Info>())).revision as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Aarch64Info),
            "::",
            stringify!(revision)
        )
    );
}
extern "C" {
    pub fn GetAarch64Info() -> Aarch64Info;
}
pub const Aarch64FeaturesEnum_AARCH64_FP: Aarch64FeaturesEnum = 0;
pub const Aarch64FeaturesEnum_AARCH64_ASIMD: Aarch64FeaturesEnum = 1;
pub const Aarch64FeaturesEnum_AARCH64_EVTSTRM: Aarch64FeaturesEnum = 2;
pub const Aarch64FeaturesEnum_AARCH64_AES: Aarch64FeaturesEnum = 3;
pub const Aarch64FeaturesEnum_AARCH64_PMULL: Aarch64FeaturesEnum = 4;
pub const Aarch64FeaturesEnum_AARCH64_SHA1: Aarch64FeaturesEnum = 5;
pub const Aarch64FeaturesEnum_AARCH64_SHA2: Aarch64FeaturesEnum = 6;
pub const Aarch64FeaturesEnum_AARCH64_CRC32: Aarch64FeaturesEnum = 7;
pub const Aarch64FeaturesEnum_AARCH64_ATOMICS: Aarch64FeaturesEnum = 8;
pub const Aarch64FeaturesEnum_AARCH64_FPHP: Aarch64FeaturesEnum = 9;
pub const Aarch64FeaturesEnum_AARCH64_ASIMDHP: Aarch64FeaturesEnum = 10;
pub const Aarch64FeaturesEnum_AARCH64_CPUID: Aarch64FeaturesEnum = 11;
pub const Aarch64FeaturesEnum_AARCH64_ASIMDRDM: Aarch64FeaturesEnum = 12;
pub const Aarch64FeaturesEnum_AARCH64_JSCVT: Aarch64FeaturesEnum = 13;
pub const Aarch64FeaturesEnum_AARCH64_FCMA: Aarch64FeaturesEnum = 14;
pub const Aarch64FeaturesEnum_AARCH64_LRCPC: Aarch64FeaturesEnum = 15;
pub const Aarch64FeaturesEnum_AARCH64_DCPOP: Aarch64FeaturesEnum = 16;
pub const Aarch64FeaturesEnum_AARCH64_SHA3: Aarch64FeaturesEnum = 17;
pub const Aarch64FeaturesEnum_AARCH64_SM3: Aarch64FeaturesEnum = 18;
pub const Aarch64FeaturesEnum_AARCH64_SM4: Aarch64FeaturesEnum = 19;
pub const Aarch64FeaturesEnum_AARCH64_ASIMDDP: Aarch64FeaturesEnum = 20;
pub const Aarch64FeaturesEnum_AARCH64_SHA512: Aarch64FeaturesEnum = 21;
pub const Aarch64FeaturesEnum_AARCH64_SVE: Aarch64FeaturesEnum = 22;
pub const Aarch64FeaturesEnum_AARCH64_ASIMDFHM: Aarch64FeaturesEnum = 23;
pub const Aarch64FeaturesEnum_AARCH64_DIT: Aarch64FeaturesEnum = 24;
pub const Aarch64FeaturesEnum_AARCH64_USCAT: Aarch64FeaturesEnum = 25;
pub const Aarch64FeaturesEnum_AARCH64_ILRCPC: Aarch64FeaturesEnum = 26;
pub const Aarch64FeaturesEnum_AARCH64_FLAGM: Aarch64FeaturesEnum = 27;
pub const Aarch64FeaturesEnum_AARCH64_SSBS: Aarch64FeaturesEnum = 28;
pub const Aarch64FeaturesEnum_AARCH64_SB: Aarch64FeaturesEnum = 29;
pub const Aarch64FeaturesEnum_AARCH64_PACA: Aarch64FeaturesEnum = 30;
pub const Aarch64FeaturesEnum_AARCH64_PACG: Aarch64FeaturesEnum = 31;
pub const Aarch64FeaturesEnum_AARCH64_DCPODP: Aarch64FeaturesEnum = 32;
pub const Aarch64FeaturesEnum_AARCH64_SVE2: Aarch64FeaturesEnum = 33;
pub const Aarch64FeaturesEnum_AARCH64_SVEAES: Aarch64FeaturesEnum = 34;
pub const Aarch64FeaturesEnum_AARCH64_SVEPMULL: Aarch64FeaturesEnum = 35;
pub const Aarch64FeaturesEnum_AARCH64_SVEBITPERM: Aarch64FeaturesEnum = 36;
pub const Aarch64FeaturesEnum_AARCH64_SVESHA3: Aarch64FeaturesEnum = 37;
pub const Aarch64FeaturesEnum_AARCH64_SVESM4: Aarch64FeaturesEnum = 38;
pub const Aarch64FeaturesEnum_AARCH64_FLAGM2: Aarch64FeaturesEnum = 39;
pub const Aarch64FeaturesEnum_AARCH64_FRINT: Aarch64FeaturesEnum = 40;
pub const Aarch64FeaturesEnum_AARCH64_SVEI8MM: Aarch64FeaturesEnum = 41;
pub const Aarch64FeaturesEnum_AARCH64_SVEF32MM: Aarch64FeaturesEnum = 42;
pub const Aarch64FeaturesEnum_AARCH64_SVEF64MM: Aarch64FeaturesEnum = 43;
pub const Aarch64FeaturesEnum_AARCH64_SVEBF16: Aarch64FeaturesEnum = 44;
pub const Aarch64FeaturesEnum_AARCH64_I8MM: Aarch64FeaturesEnum = 45;
pub const Aarch64FeaturesEnum_AARCH64_BF16: Aarch64FeaturesEnum = 46;
pub const Aarch64FeaturesEnum_AARCH64_DGH: Aarch64FeaturesEnum = 47;
pub const Aarch64FeaturesEnum_AARCH64_RNG: Aarch64FeaturesEnum = 48;
pub const Aarch64FeaturesEnum_AARCH64_BTI: Aarch64FeaturesEnum = 49;
pub const Aarch64FeaturesEnum_AARCH64_MTE: Aarch64FeaturesEnum = 50;
pub const Aarch64FeaturesEnum_AARCH64_ECV: Aarch64FeaturesEnum = 51;
pub const Aarch64FeaturesEnum_AARCH64_AFP: Aarch64FeaturesEnum = 52;
pub const Aarch64FeaturesEnum_AARCH64_RPRES: Aarch64FeaturesEnum = 53;
pub const Aarch64FeaturesEnum_AARCH64_LAST_: Aarch64FeaturesEnum = 54;
#[doc = ""]
pub type Aarch64FeaturesEnum = cty::c_uint;
extern "C" {
    pub fn GetAarch64FeaturesEnumValue(
        features: *const Aarch64Features,
        value: Aarch64FeaturesEnum,
    ) -> cty::c_int;
}
extern "C" {
    pub fn GetAarch64FeaturesEnumName(arg1: Aarch64FeaturesEnum) -> *const cty::c_char;
}
