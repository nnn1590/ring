/* automatically generated by rust-bindgen 0.59.2 */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals, unused)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const CPU_FEATURES_COMPILED_X86_AES: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_F16C: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_BMI: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_BMI2: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_SSE: u32 = 1;
pub const CPU_FEATURES_COMPILED_X86_SSE2: u32 = 1;
pub const CPU_FEATURES_COMPILED_X86_SSE3: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_SSSE3: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_SSE4_1: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_SSE4_2: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_AVX: u32 = 0;
pub const CPU_FEATURES_COMPILED_X86_AVX2: u32 = 0;
pub const CPU_FEATURES_MAX_CACHE_LEVEL: u32 = 10;
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = cty::c_long;
pub type __u_quad_t = cty::c_ulong;
pub type __intmax_t = cty::c_long;
pub type __uintmax_t = cty::c_ulong;
pub type __dev_t = cty::c_ulong;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = cty::c_ulong;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_ulong;
pub type __off_t = cty::c_long;
pub type __off64_t = cty::c_long;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = cty::c_ulong;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = cty::c_long;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = cty::c_ulong;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = cty::c_ulong;
pub type __fsword_t = cty::c_long;
pub type __ssize_t = cty::c_long;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_long;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_long;
pub type int_fast32_t = cty::c_long;
pub type int_fast64_t = cty::c_long;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_ulong;
pub type uint_fast32_t = cty::c_ulong;
pub type uint_fast64_t = cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const CacheType_CPU_FEATURE_CACHE_NULL: CacheType = 0;
pub const CacheType_CPU_FEATURE_CACHE_DATA: CacheType = 1;
pub const CacheType_CPU_FEATURE_CACHE_INSTRUCTION: CacheType = 2;
pub const CacheType_CPU_FEATURE_CACHE_UNIFIED: CacheType = 3;
pub const CacheType_CPU_FEATURE_CACHE_TLB: CacheType = 4;
pub const CacheType_CPU_FEATURE_CACHE_DTLB: CacheType = 5;
pub const CacheType_CPU_FEATURE_CACHE_STLB: CacheType = 6;
pub const CacheType_CPU_FEATURE_CACHE_PREFETCH: CacheType = 7;
pub type CacheType = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CacheLevelInfo {
    pub level: cty::c_int,
    pub cache_type: CacheType,
    pub cache_size: cty::c_int,
    pub ways: cty::c_int,
    pub line_size: cty::c_int,
    pub tlb_entries: cty::c_int,
    pub partitioning: cty::c_int,
}
#[test]
fn bindgen_test_layout_CacheLevelInfo() {
    assert_eq!(
        ::core::mem::size_of::<CacheLevelInfo>(),
        28usize,
        concat!("Size of: ", stringify!(CacheLevelInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<CacheLevelInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(CacheLevelInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).cache_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(cache_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).cache_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).ways as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(ways)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).line_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(line_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).tlb_entries as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(tlb_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheLevelInfo>())).partitioning as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheLevelInfo),
            "::",
            stringify!(partitioning)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CacheInfo {
    pub size: cty::c_int,
    pub levels: [CacheLevelInfo; 10usize],
}
#[test]
fn bindgen_test_layout_CacheInfo() {
    assert_eq!(
        ::core::mem::size_of::<CacheInfo>(),
        284usize,
        concat!("Size of: ", stringify!(CacheInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<CacheInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(CacheInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheInfo>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CacheInfo>())).levels as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CacheInfo),
            "::",
            stringify!(levels)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ArmFeatures {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ArmFeatures() {
    assert_eq!(
        ::core::mem::size_of::<ArmFeatures>(),
        4usize,
        concat!("Size of: ", stringify!(ArmFeatures))
    );
    assert_eq!(
        ::core::mem::align_of::<ArmFeatures>(),
        4usize,
        concat!("Alignment of ", stringify!(ArmFeatures))
    );
}
impl ArmFeatures {
    #[inline]
    pub fn swp(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swp(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn half(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_half(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thumb(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thumb(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _26bit(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__26bit(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmult(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmult(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fpa(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fpa(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vfp(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vfp(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn edsp(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_edsp(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn java(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_java(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn iwmmxt(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iwmmxt(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn crunch(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crunch(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thumbee(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thumbee(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn neon(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_neon(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vfpv3(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vfpv3(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vfpv3d16(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vfpv3d16(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tls(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tls(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vfpv4(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vfpv4(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn idiva(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idiva(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn idivt(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idivt(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vfpd32(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vfpd32(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lpae(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lpae(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn evtstrm(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_evtstrm(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aes(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aes(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pmull(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pmull(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sha1(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sha1(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sha2(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sha2(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn crc32(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crc32(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        swp: cty::c_int,
        half: cty::c_int,
        thumb: cty::c_int,
        _26bit: cty::c_int,
        fastmult: cty::c_int,
        fpa: cty::c_int,
        vfp: cty::c_int,
        edsp: cty::c_int,
        java: cty::c_int,
        iwmmxt: cty::c_int,
        crunch: cty::c_int,
        thumbee: cty::c_int,
        neon: cty::c_int,
        vfpv3: cty::c_int,
        vfpv3d16: cty::c_int,
        tls: cty::c_int,
        vfpv4: cty::c_int,
        idiva: cty::c_int,
        idivt: cty::c_int,
        vfpd32: cty::c_int,
        lpae: cty::c_int,
        evtstrm: cty::c_int,
        aes: cty::c_int,
        pmull: cty::c_int,
        sha1: cty::c_int,
        sha2: cty::c_int,
        crc32: cty::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let swp: u32 = unsafe { ::core::mem::transmute(swp) };
            swp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let half: u32 = unsafe { ::core::mem::transmute(half) };
            half as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let thumb: u32 = unsafe { ::core::mem::transmute(thumb) };
            thumb as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let _26bit: u32 = unsafe { ::core::mem::transmute(_26bit) };
            _26bit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fastmult: u32 = unsafe { ::core::mem::transmute(fastmult) };
            fastmult as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let fpa: u32 = unsafe { ::core::mem::transmute(fpa) };
            fpa as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let vfp: u32 = unsafe { ::core::mem::transmute(vfp) };
            vfp as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let edsp: u32 = unsafe { ::core::mem::transmute(edsp) };
            edsp as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let java: u32 = unsafe { ::core::mem::transmute(java) };
            java as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let iwmmxt: u32 = unsafe { ::core::mem::transmute(iwmmxt) };
            iwmmxt as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let crunch: u32 = unsafe { ::core::mem::transmute(crunch) };
            crunch as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let thumbee: u32 = unsafe { ::core::mem::transmute(thumbee) };
            thumbee as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let neon: u32 = unsafe { ::core::mem::transmute(neon) };
            neon as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let vfpv3: u32 = unsafe { ::core::mem::transmute(vfpv3) };
            vfpv3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let vfpv3d16: u32 = unsafe { ::core::mem::transmute(vfpv3d16) };
            vfpv3d16 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tls: u32 = unsafe { ::core::mem::transmute(tls) };
            tls as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let vfpv4: u32 = unsafe { ::core::mem::transmute(vfpv4) };
            vfpv4 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let idiva: u32 = unsafe { ::core::mem::transmute(idiva) };
            idiva as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let idivt: u32 = unsafe { ::core::mem::transmute(idivt) };
            idivt as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let vfpd32: u32 = unsafe { ::core::mem::transmute(vfpd32) };
            vfpd32 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let lpae: u32 = unsafe { ::core::mem::transmute(lpae) };
            lpae as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let evtstrm: u32 = unsafe { ::core::mem::transmute(evtstrm) };
            evtstrm as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let aes: u32 = unsafe { ::core::mem::transmute(aes) };
            aes as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let pmull: u32 = unsafe { ::core::mem::transmute(pmull) };
            pmull as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let sha1: u32 = unsafe { ::core::mem::transmute(sha1) };
            sha1 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let sha2: u32 = unsafe { ::core::mem::transmute(sha2) };
            sha2 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let crc32: u32 = unsafe { ::core::mem::transmute(crc32) };
            crc32 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArmInfo {
    pub features: ArmFeatures,
    pub implementer: cty::c_int,
    pub architecture: cty::c_int,
    pub variant: cty::c_int,
    pub part: cty::c_int,
    pub revision: cty::c_int,
}
#[test]
fn bindgen_test_layout_ArmInfo() {
    assert_eq!(
        ::core::mem::size_of::<ArmInfo>(),
        24usize,
        concat!("Size of: ", stringify!(ArmInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<ArmInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ArmInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ArmInfo>())).features as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArmInfo),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ArmInfo>())).implementer as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ArmInfo),
            "::",
            stringify!(implementer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ArmInfo>())).architecture as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArmInfo),
            "::",
            stringify!(architecture)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ArmInfo>())).variant as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ArmInfo),
            "::",
            stringify!(variant)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ArmInfo>())).part as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArmInfo),
            "::",
            stringify!(part)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ArmInfo>())).revision as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ArmInfo),
            "::",
            stringify!(revision)
        )
    );
}
extern "C" {
    pub fn GetArmInfo() -> ArmInfo;
}
extern "C" {
    pub fn GetArmCpuId(info: *const ArmInfo) -> u32;
}
pub const ArmFeaturesEnum_ARM_SWP: ArmFeaturesEnum = 0;
pub const ArmFeaturesEnum_ARM_HALF: ArmFeaturesEnum = 1;
pub const ArmFeaturesEnum_ARM_THUMB: ArmFeaturesEnum = 2;
pub const ArmFeaturesEnum_ARM_26BIT: ArmFeaturesEnum = 3;
pub const ArmFeaturesEnum_ARM_FASTMULT: ArmFeaturesEnum = 4;
pub const ArmFeaturesEnum_ARM_FPA: ArmFeaturesEnum = 5;
pub const ArmFeaturesEnum_ARM_VFP: ArmFeaturesEnum = 6;
pub const ArmFeaturesEnum_ARM_EDSP: ArmFeaturesEnum = 7;
pub const ArmFeaturesEnum_ARM_JAVA: ArmFeaturesEnum = 8;
pub const ArmFeaturesEnum_ARM_IWMMXT: ArmFeaturesEnum = 9;
pub const ArmFeaturesEnum_ARM_CRUNCH: ArmFeaturesEnum = 10;
pub const ArmFeaturesEnum_ARM_THUMBEE: ArmFeaturesEnum = 11;
pub const ArmFeaturesEnum_ARM_NEON: ArmFeaturesEnum = 12;
pub const ArmFeaturesEnum_ARM_VFPV3: ArmFeaturesEnum = 13;
pub const ArmFeaturesEnum_ARM_VFPV3D16: ArmFeaturesEnum = 14;
pub const ArmFeaturesEnum_ARM_TLS: ArmFeaturesEnum = 15;
pub const ArmFeaturesEnum_ARM_VFPV4: ArmFeaturesEnum = 16;
pub const ArmFeaturesEnum_ARM_IDIVA: ArmFeaturesEnum = 17;
pub const ArmFeaturesEnum_ARM_IDIVT: ArmFeaturesEnum = 18;
pub const ArmFeaturesEnum_ARM_VFPD32: ArmFeaturesEnum = 19;
pub const ArmFeaturesEnum_ARM_LPAE: ArmFeaturesEnum = 20;
pub const ArmFeaturesEnum_ARM_EVTSTRM: ArmFeaturesEnum = 21;
pub const ArmFeaturesEnum_ARM_AES: ArmFeaturesEnum = 22;
pub const ArmFeaturesEnum_ARM_PMULL: ArmFeaturesEnum = 23;
pub const ArmFeaturesEnum_ARM_SHA1: ArmFeaturesEnum = 24;
pub const ArmFeaturesEnum_ARM_SHA2: ArmFeaturesEnum = 25;
pub const ArmFeaturesEnum_ARM_CRC32: ArmFeaturesEnum = 26;
pub const ArmFeaturesEnum_ARM_LAST_: ArmFeaturesEnum = 27;
#[doc = ""]
pub type ArmFeaturesEnum = cty::c_uint;
extern "C" {
    pub fn GetArmFeaturesEnumValue(
        features: *const ArmFeatures,
        value: ArmFeaturesEnum,
    ) -> cty::c_int;
}
extern "C" {
    pub fn GetArmFeaturesEnumName(arg1: ArmFeaturesEnum) -> *const cty::c_char;
}
